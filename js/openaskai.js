/**
 * OpenAskAI Page Functionality
 */
document.addEventListener('DOMContentLoaded', function() {
  // Initialize OpenAskAI
  initializeAI();
  initializeQuickActions();
  initializeFAQ();
  
  // Chat elements
  const chatInput = document.getElementById('chatInput');
  const sendButton = document.getElementById('sendButton');
  const chatMessages = document.getElementById('chatMessages');
  const clearChatBtn = document.getElementById('clearChat');
  const newChatBtn = document.getElementById('newChat');
  const suggestionChips = document.querySelectorAll('.suggestion-chip');
  
  function initializeAI() {
    // Send button functionality
    if (sendButton) {
      sendButton.addEventListener('click', handleSendMessage);
    }
    
    // Enter key functionality
    if (chatInput) {
      chatInput.addEventListener('keypress', function(e) {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          handleSendMessage();
        }
      });
      
      // Input validation
      chatInput.addEventListener('input', function() {
        const message = this.value.trim();
        sendButton.disabled = message.length === 0;
        
        // Show suggestions when input is empty
        const suggestions = document.getElementById('inputSuggestions');
        if (suggestions) {
          suggestions.style.display = message.length === 0 ? 'flex' : 'none';
        }
      });
    }
    
    // Clear chat functionality
    if (clearChatBtn) {
      clearChatBtn.addEventListener('click', clearChat);
    }
    
    // New chat functionality
    if (newChatBtn) {
      newChatBtn.addEventListener('click', startNewChat);
    }
    
    // Suggestion chips
    suggestionChips.forEach(chip => {
      chip.addEventListener('click', function() {
        const text = this.dataset.text;
        chatInput.value = text;
        handleSendMessage();
      });
    });
  }
  
  function initializeQuickActions() {
    const quickActionCards = document.querySelectorAll('.quick-action-card');
    
    quickActionCards.forEach(card => {
      card.addEventListener('click', function() {
        const question = this.dataset.question;
        if (question) {
          chatInput.value = question;
          scrollToChat();
          setTimeout(() => {
            handleSendMessage();
          }, 300);
        }
      });
    });
  }
  
  function initializeFAQ() {
    const faqItems = document.querySelectorAll('.faq-item');
    
    faqItems.forEach(item => {
      const question = item.querySelector('.faq-question');
      question.addEventListener('click', function() {
        // Close other FAQ items
        faqItems.forEach(otherItem => {
          if (otherItem !== item) {
            otherItem.classList.remove('open');
          }
        });
        
        // Toggle current item
        item.classList.toggle('open');
      });
    });
  }
  
  function handleSendMessage() {
    const message = chatInput.value.trim();
    if (!message) return;
    
    // Disable input and button
    chatInput.disabled = true;
    sendButton.disabled = true;
    
    // Add user message
    addMessage(message, 'user');
    
    // Clear input
    chatInput.value = '';
    
    // Show typing indicator
    showTypingIndicator();
    
    // Simulate AI response
    setTimeout(() => {
      hideTypingIndicator();
      generateAIResponse(message);
      
      // Re-enable input
      chatInput.disabled = false;
      sendButton.disabled = false;
      chatInput.focus();
    }, Math.random() * 2000 + 1000); // Random delay between 1-3 seconds
  }
  
  function addMessage(text, sender, isHTML = false) {
    const messageDiv = document.createElement('div');
    messageDiv.className = `message ${sender}-message`;
    
    const currentTime = new Date().toLocaleTimeString('vi-VN', { 
      hour: '2-digit', 
      minute: '2-digit' 
    });
    
    messageDiv.innerHTML = `
      <div class="message-avatar">
        <i class="fas fa-${sender === 'user' ? 'user' : 'robot'}"></i>
      </div>
      <div class="message-content">
        <div class="message-text">
          ${isHTML ? text : text}
        </div>
        <div class="message-time">${currentTime}</div>
      </div>
    `;
    
    chatMessages.appendChild(messageDiv);
    scrollToBottom();
  }
  
  function showTypingIndicator() {
    const typingDiv = document.createElement('div');
    typingDiv.className = 'message ai-message typing';
    typingDiv.innerHTML = `
      <div class="message-avatar">
        <i class="fas fa-robot"></i>
      </div>
      <div class="message-content">
        <div class="typing-indicator">
          <div class="typing-dot"></div>
          <div class="typing-dot"></div>
          <div class="typing-dot"></div>
        </div>
      </div>
    `;
    
    chatMessages.appendChild(typingDiv);
    scrollToBottom();
  }
  
  function hideTypingIndicator() {
    const typingIndicator = chatMessages.querySelector('.typing');
    if (typingIndicator) {
      typingIndicator.remove();
    }
  }
  
  function generateAIResponse(userMessage) {
    // Simple keyword-based responses for demo
    const responses = getAIResponse(userMessage);
    addMessage(responses.text, 'ai', responses.isHTML);
  }
  
  function getAIResponse(message) {
    const lowerMessage = message.toLowerCase();
    
    // Dataset related queries
    if (lowerMessage.includes('dataset') || lowerMessage.includes('d·ªØ li·ªáu')) {
      if (lowerMessage.includes('t·∫£i l√™n') || lowerMessage.includes('upload')) {
        return {
          text: `ƒê·ªÉ t·∫£i dataset l√™n OpenData, b·∫°n c·∫ßn l√†m theo c√°c b∆∞·ªõc sau:
          <ol>
            <li>ƒêƒÉng nh·∫≠p v√†o t√†i kho·∫£n OpenData c·ªßa b·∫°n</li>
            <li>Ch·ªçn "Upload Dataset" t·ª´ menu ho·∫∑c trang ch·ªß</li>
            <li>ƒêi·ªÅn th√¥ng tin c∆° b·∫£n: t√™n dataset, m√¥ t·∫£, li√™n k·∫øt</li>
            <li>Ch·ªçn paper li√™n quan v√† s·ªë l∆∞·ª£ng m·∫´u</li>
            <li>Ch·ªçn licence v√† tags ph√π h·ª£p</li>
            <li>X√°c nh·∫≠n v√† g·ª≠i ƒë·ªÉ ƒë∆∞·ª£c duy·ªát</li>
          </ol>
          <p>L∆∞u √Ω: Dataset ph·∫£i ƒë∆∞·ª£c c√¥ng b·ªë trong paper khoa h·ªçc uy t√≠n ƒë·ªÉ ƒë∆∞·ª£c ch·∫•p nh·∫≠n.</p>`,
          isHTML: true
        };
      }
      
      if (lowerMessage.includes('multimodal') || lowerMessage.includes('ƒëa ph∆∞∆°ng th·ª©c')) {
        return {
          text: `Dataset multimodal l√† nh·ªØng b·ªô d·ªØ li·ªáu ch·ª©a nhi·ªÅu lo·∫°i d·ªØ li·ªáu kh√°c nhau nh∆∞:
          <ul>
            <li><strong>Text + Image:</strong> V√≠ d·ª• nh∆∞ COCO (v·ªõi caption cho ·∫£nh)</li>
            <li><strong>Audio + Video:</strong> D·ªØ li·ªáu speech v·ªõi visual cues</li>
            <li><strong>Text + Audio:</strong> Podcast transcripts</li>
            <li><strong>Image + Text + Audio:</strong> Video v·ªõi subtitle v√† audio</li>
          </ul>
          <p>Nh·ªØng dataset n√†y r·∫•t quan tr·ªçng cho c√°c task nh∆∞ image captioning, video understanding, v√† cross-modal retrieval.</p>`,
          isHTML: true
        };
      }
      
      if (lowerMessage.includes('t√¨m') || lowerMessage.includes('search')) {
        return {
          text: `ƒê·ªÉ t√¨m dataset ph√π h·ª£p tr√™n OpenData:
          <ol>
            <li>S·ª≠ d·ª•ng thanh t√¨m ki·∫øm v·ªõi t·ª´ kh√≥a li√™n quan</li>
            <li>L·ªçc theo modality (Image, Text, Audio, Video, Multimodal)</li>
            <li>Xem th·∫ª tags ƒë·ªÉ t√¨m dataset c√πng domain</li>
            <li>Ki·ªÉm tra size v√† s·ªë sample ph√π h·ª£p v·ªõi t√†i nguy√™n</li>
            <li>ƒê·ªçc k·ªπ m√¥ t·∫£ v√† paper g·ªëc ƒë·ªÉ hi·ªÉu r√µ dataset</li>
          </ol>
          <p>Tip: Datasets ƒë∆∞·ª£c s·∫Øp x·∫øp theo ƒë·ªô ph·ªï bi·∫øn v√† c√≥ th·ªÉ filter theo licence!</p>`,
          isHTML: true
        };
      }
    }
    
    // Metrics related queries
    if (lowerMessage.includes('metrics') || lowerMessage.includes('ƒë√°nh gi√°')) {
      if (lowerMessage.includes('ph·ªï bi·∫øn') || lowerMessage.includes('popular') || lowerMessage.includes('common')) {
        return {
          text: `C√°c metrics ph·ªï bi·∫øn trong Machine Learning:
          
          <strong>üéØ Classification:</strong>
          ‚Ä¢ Accuracy, Precision, Recall, F1-Score
          ‚Ä¢ Top-k Error (ƒë·∫∑c bi·ªát useful cho nhi·ªÅu classes)
          
          <strong>üîç Object Detection:</strong>
          ‚Ä¢ mAP (mean Average Precision)
          ‚Ä¢ IoU (Intersection over Union)
          ‚Ä¢ FPS (Frames per Second) cho real-time
          
          <strong>üó£Ô∏è NLP:</strong>
          ‚Ä¢ BLEU (Machine Translation)
          ‚Ä¢ ROUGE (Summarization)
          ‚Ä¢ Perplexity (Language Models)
          
          <strong>üîä Speech:</strong>
          ‚Ä¢ WER (Word Error Rate)
          ‚Ä¢ CER (Character Error Rate)
          
          L·ª±a ch·ªçn metric ph·ª• thu·ªôc v√†o task c·ª• th·ªÉ v√† m·ª•c ti√™u c·ªßa b·∫°n!`,
          isHTML: true
        };
      }
      
      if (lowerMessage.includes('kh√°c bi·ªát') || lowerMessage.includes('difference')) {
        return {
          text: `ü§î S·ª± kh√°c bi·ªát ch√≠nh gi·ªØa c√°c metrics:
          
          <strong>Precision vs Recall:</strong>
          ‚Ä¢ Precision: "Trong nh·ªØng g√¨ m√¥ h√¨nh d·ª± ƒëo√°n l√† Positive, bao nhi√™u % th·ª±c s·ª± ƒë√∫ng?"
          ‚Ä¢ Recall: "Trong nh·ªØng g√¨ th·ª±c s·ª± l√† Positive, m√¥ h√¨nh catch ƒë∆∞·ª£c bao nhi√™u %?"
          
          <strong>F1-Score:</strong>
          ‚Ä¢ Harmonic mean c·ªßa Precision v√† Recall
          ‚Ä¢ C√¢n b·∫±ng gi·ªØa hai metrics n√†y
          
          <strong>Top-1 vs Top-k Error:</strong>
          ‚Ä¢ Top-1: Ch·ªâ ƒë√°nh gi√° prediction c√≥ confidence cao nh·∫•t
          ‚Ä¢ Top-k: ƒê√°nh gi√° xem label ƒë√∫ng c√≥ n·∫±m trong k predictions cao nh·∫•t
          
          <strong>mAP vs IoU:</strong>
          ‚Ä¢ IoU: ƒêo overlap gi·ªØa prediction box v√† ground truth
          ‚Ä¢ mAP: T·ªïng h·ª£p precision-recall curve cho detection task
          
          M·ªói metric ph√π h·ª£p v·ªõi t·ª´ng use case c·ª• th·ªÉ! üéØ`,
          isHTML: true
        };
      }
    }
    
    // Paper related queries
    if (lowerMessage.includes('paper') || lowerMessage.includes('b√†i b√°o')) {
      if (lowerMessage.includes('upload') || lowerMessage.includes('t·∫£i l√™n')) {
        return {
          text: `üî¨ H∆∞·ªõng d·∫´n upload paper l√™n OpenData:
          
          <strong>B∆∞·ªõc 1: Chu·∫©n b·ªã th√¥ng tin</strong>
          ‚Ä¢ Ti√™u ƒë·ªÅ paper ƒë·∫ßy ƒë·ªß
          ‚Ä¢ Danh s√°ch t√°c gi·∫£
          ‚Ä¢ Abstract/t√≥m t·∫Øt
          ‚Ä¢ Link paper (PDF ho·∫∑c arXiv)
          ‚Ä¢ DOI (n·∫øu c√≥)
          
          <strong>B∆∞·ªõc 2: Upload</strong>
          ‚Ä¢ V√†o m·ª•c "Upload Paper"
          ‚Ä¢ ƒêi·ªÅn form v·ªõi th√¥ng tin ch√≠nh x√°c
          ‚Ä¢ Ch·ªçn h·ªôi ngh·ªã/journal
          ‚Ä¢ Ch·ªçn research area
          ‚Ä¢ Add keywords
          
          <strong>B∆∞·ªõc 3: X√°c th·ª±c</strong>
          ‚Ä¢ OpenData s·∫Ω verify paper t·ª´ ngu·ªìn uy t√≠n
          ‚Ä¢ Th√¥ng b√°o approval trong 24-48h
          
          Paper ph·∫£i ƒë∆∞·ª£c publish ·ªü conference/journal c√≥ uy t√≠n! üìö`,
          isHTML: true
        };
      }
    }
    
    // Benchmark related queries
    if (lowerMessage.includes('benchmark')) {
      if (lowerMessage.includes('t·∫°o') || lowerMessage.includes('create')) {
        return {
          text: `üèÜ Quy tr√¨nh t·∫°o benchmark m·ªõi:
          
          <strong>B∆∞·ªõc 1: Th√¥ng tin c∆° b·∫£n</strong>
          ‚Ä¢ ƒê·∫∑t t√™n benchmark r√µ r√†ng
          ‚Ä¢ M√¥ t·∫£ chi ti·∫øt v·ªÅ m·ª•c ƒë√≠ch
          
          <strong>B∆∞·ªõc 2: Ch·ªçn Dataset & Task</strong>
          ‚Ä¢ Ch·ªçn dataset t·ª´ library c√≥ s·∫µn
          ‚Ä¢ Ho·∫∑c upload dataset m·ªõi n·∫øu ch∆∞a c√≥
          ‚Ä¢ X√°c ƒë·ªãnh task c·ª• th·ªÉ (classification, detection...)
          
          <strong>B∆∞·ªõc 3: Ch·ªçn Metrics</strong>
          ‚Ä¢ T·ªëi ƒëa 10 metrics cho 1 benchmark  
          ‚Ä¢ H·ªá th·ªëng s·∫Ω g·ª£i √Ω metrics ph√π h·ª£p
          ‚Ä¢ C√≥ th·ªÉ add custom metrics
          
          <strong>B∆∞·ªõc 4: Th√¥ng tin b·ªï sung</strong>
          ‚Ä¢ Link paper g·ªëc (tu·ª≥ ch·ªçn)
          ‚Ä¢ Link code implementation
          ‚Ä¢ Link leaderboard
          
          Benchmark gi√∫p standardize vi·ªác ƒë√°nh gi√° m√¥ h√¨nh! üìä`,
          isHTML: true
        };
      }
    }
    
    // General help queries
    if (lowerMessage.includes('help') || lowerMessage.includes('h∆∞·ªõng d·∫´n') || lowerMessage.includes('guide')) {
      return {
        text: `üöÄ T√¥i c√≥ th·ªÉ gi√∫p b·∫°n v·ªõi:
        
        <strong>üìä Datasets:</strong> T√¨m, t·∫£i, upload, hi·ªÉu v·ªÅ c√°c lo·∫°i dataset
        
        <strong>üìö Papers:</strong> Qu·∫£n l√Ω papers, citation, research areas
        
        <strong>üéØ Benchmarks:</strong> T·∫°o, s·ª≠ d·ª•ng, so s√°nh benchmarks
        
        <strong>üìà Metrics:</strong> Hi·ªÉu v√† ch·ªçn metrics ph√π h·ª£p
        
        <strong>üîß Platform:</strong> S·ª≠ d·ª•ng c√°c t√≠nh nƒÉng c·ªßa OpenData
        
        <strong>üó∫Ô∏è Maps:</strong> T√¨m institutions v√† authors
        
        H√£y ƒë·∫∑t c√¢u h·ªèi c·ª• th·ªÉ ƒë·ªÉ t√¥i h·ªó tr·ª£ t·ªët nh·∫•t! üòä`,
        isHTML: true
      };
    }
    
    // Default response
    return {
      text: `C·∫£m ∆°n b·∫°n ƒë√£ h·ªèi! T√¥i hi·ªán chuy√™n v·ªÅ:
      
      ‚Ä¢ üìä Datasets v√† c√°ch s·ª≠ d·ª•ng
      ‚Ä¢ üìö Papers v√† nghi√™n c·ª©u
      ‚Ä¢ üéØ Benchmarks v√† ƒë√°nh gi√°
      ‚Ä¢ üìà Metrics v√† optimization
      ‚Ä¢ üîß H∆∞·ªõng d·∫´n s·ª≠ d·ª•ng OpenData
      
      C√≥ th·ªÉ b·∫°n mu·ªën h·ªèi v·ªÅ:
      ‚Ä¢ "C√°ch t·∫£i dataset l√™n OpenData?"
      ‚Ä¢ "Gi·∫£i th√≠ch c√°c metrics ph·ªï bi·∫øn?"
      ‚Ä¢ "H∆∞·ªõng d·∫´n t·∫°o benchmark m·ªõi?"
      
      H√£y ƒë·∫∑t c√¢u h·ªèi c·ª• th·ªÉ h∆°n ƒë·ªÉ t√¥i h·ªó tr·ª£ t·ªët nh·∫•t! üòä`,
      isHTML: true
    };
  }
  
  function clearChat() {
    if (confirm('B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a t·∫•t c·∫£ cu·ªôc tr√≤ chuy·ªán?')) {
      // Keep only the welcome message
      const firstMessage = chatMessages.querySelector('.message');
      chatMessages.innerHTML = '';
      if (firstMessage) {
        chatMessages.appendChild(firstMessage);
      }
    }
  }
  
  function startNewChat() {
    clearChat();
    chatInput.value = '';
    sendButton.disabled = true;
    document.getElementById('inputSuggestions').style.display = 'flex';
  }
  
  function scrollToBottom() {
    chatMessages.scrollTop = chatMessages.scrollHeight;
  }
  
  function scrollToChat() {
    const chatContainer = document.querySelector('.chat-container');
    chatContainer.scrollIntoView({ behavior: 'smooth' });
  }
  
  // Initialize button state
  if (sendButton) {
    sendButton.disabled = true;
  }
  
  // Show initial suggestions
  const suggestions = document.getElementById('inputSuggestions');
  if (suggestions) {
    suggestions.style.display = 'flex';
  }
});